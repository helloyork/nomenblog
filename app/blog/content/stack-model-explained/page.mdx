---
title: "How Does StackModel Change My Game Engine"
date: "2025-09-12"
description: "Stack Model Explained"
---

# StackModel是如何改变我的游戏引擎的

## 引言

StackModel是我为NarraLeaf-React设计的一个游戏流程执行模型，提供了一个复杂的基于栈的架构，用于管理复杂的叙事操作、状态持久化和异步执行流程。

有关于NarraLeaf-React视觉小说框架，请参考[NarraLeaf-React](https://react.narraleaf.com/). 

本文将围绕其核心逻辑StackModel展开研究，并且解释这个设计背后的原理。

## 架构演变

### 单节点动作模型

NarraLeaf-React使用静态剧情节点树来储存游戏剧情逻辑，有关引擎基本的流程结构，请访问[NarraLeaf React背后的设计理念](../narraleaf-react-design/)

在一开始，NarraLeaf-React使用单个变量来引用当前正在执行的节点，这保证引擎可以轻松获取当前的执行状态和预测未来的节点，
该做法简单并且易于调试。但是，这个做法很快就被意识到是错误的。

随着剧情和叙事变复杂，故事中会出现嵌套的操作，也就是可选或额外的独立于主线的操作。当使用单个变量来引用当前正在执行的节点时，
为了保证运行完嵌套的动作后能回归到原本的时间线，游戏不得不将嵌套动作最后一个动作的子节点指向绑定到主线上的下一个节点。  
此时，游戏节点会变为：  
```
              (extra-1) -↓
(action-1) -↑              (action-2) -> (...)
```

但是，这个做法在遇到循环和选择性支线的情况时会变得难以调试、难以理解并且令人混淆。游戏不得不在存档中维护一个增量映射表来储存节点
之间的关系。而依赖于修改和读取节点指向的执行流程管理让错误更难以发现，流程追踪变得更为复杂。  
更重要的是，这个做法打破了NarraLeaf-React的核心设计原则：剧情节点树静态特性

剧情节点树是NarraLeaf-React依赖的重要结构。这个节点树构建了剧情走向，每个节点包含的信息和节点之间的关系。强制剧情节点树静态
特性可以让剧情逻辑易于调试和追踪，避免了维护和记录节点树变更的必要，并且有助于引擎对剧情节点进行静态分析和预测。

打破这个特性不仅违背了引擎的设计哲学，还导致了相当多危险而令人困惑的特性。

### StackModel动作模型

StackModel动作模型是一次重大的架构演进，也是NarraLeaf-React对于剧情管理的最终尝试。

这次转变引入了：  
- 显式的可等待/可中断的原子任务处理（Awaitable）
- 递归任务子栈
- 完整的序列化/反序列化能力
- 可中断并且可恢复的任务模型
- 时间线模型（Timelines）
- 游离任务的控制

总而言之，这次转变带来了完整的嵌套操作解决方案，并且提供了完整的游戏中断、恢复到任意时刻和序列化支持。

该方案围绕着几个核心概念构建：  
- 尝试性的操作执行
- 嵌套的执行栈
- 方便序列化和反序列化的游戏状态快照

这次更新彻底解决了单节点动作模型存在的所有功能，并且为后来的游戏存档/读档和游戏历史记录提供了支持。

## StackModel概念

StackModel不仅指的是StackModel结构本身，也指的是包含Timelines和Awaitable在内的统一设计概念。

### Awaitable

Awaitable是StackModel执行任何异步任务的的原子操作。

Awaitable是可以解析、链接或中止的异步值的包装器，它本质上是对Promise概念的扩展和修改。  
它与Timeline紧密合作，并且在Timeline中充当广播子任务状态的成员。

Awaitable追踪任务的状态，包括正在等待、已解决和已终止三个状态。它没有已拒绝状态，因为Awaitable不被预期处理任务的错误
情况，因为Awaitable充当游戏节点的状态跟踪器，而在任何游戏节点中发生错误都是无法容忍的，并且会立即导致剧情终止。

### Timeline和Timelines

Timeline是对多个Awaitable和嵌套Timeline任务的高级封装，是协调异步操作和动画的核心系统。它为各种异步操作（例如动画、音频播放和等待用户
输入）提供统一的生命周期管理。

直观来讲，Timeline通常被用于监听多个Awaitable和Timeline的多个状态，包括向下传播和向上监听。  
Timeline的状态也包含正在等待、已解决和已终止。

Timeline通常以`all`和`any`模式执行，也就是等待所有Awaitable和嵌套Timeline解析以及等待其中任何一个任务解析。

Timeline使用一个任务相关或临时拟造的Awaitable充当其主要的状态控制器。当主Awaitable中断时或Timeline自身被中断时，整个
Timeline都会中断。当Timeline中断时，其所有的子任务，包括Awaitable和Timeline都会中断，并且向下递归传递。

而Timelines则是全局根时间线管理器，用于立即中断所有受管理的时间线。该类确保不会存在不受控的游离时间线没有正确响应游戏状态变更。

### StackModel

StackModel是一组以栈形式储存的Awaitable和节点。

简单来讲，当节点执行完后，其执行结果，也就是下一个节点或一个未解析的Awaitable，会推入栈。每次进行栈循环时，StackModel
都会尝试取出栈顶的内容并且继续执行。

详细来讲，栈在循环时会做这些事情：  
- 如果栈已空，退出循环并且交给游戏决定下一步操作
- 取出栈顶
  - 如果栈顶是可执行的节点，则执行该节点，将执行结果推入栈
  - 如果栈顶是已解析的Awaitable，将结果推入栈
  - 如果栈顶是未解析的Awaitable，返回Awaitable供调用者监听任务执行状态

而执行子Stack Model的支持则通过将StackModel执行包装为Awaitable实现。StackModel无需关心子StackModel的执行状态。

当操作想要执行
